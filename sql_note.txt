0、innodb逻辑存储结构
Innodb所有数据都被逻辑地存放在表空间，表空间又由段、区、页组成。
段：数据段、索引段、回滚段等。管理都是由引擎自身管理。
区：由连续的页组成，无论页多大，一个区的大小始终是1MB。
页：InnoDB磁盘管理的最小单位。默认大小为16KB，可以通过参数innodb_page_size来设置
0.1 oltp、olap、行锁、页锁、表锁
死锁：事务互相等待对方资源，最后形成环路[全部都在等待锁的释放]
      具体：https://www.cnblogs.com/LBSer/p/5183300.html
      A、不同表相同记录行锁冲突：事务A和事务B操作两张表，但出现循环等待锁情况。
	  B、相同表记录行锁冲突
	  ....

0.1、分区
定义：将同一表中不同行的记录分配到不同的物理文件中。同时，每个区都是独立的，可以独立处理，也可以作为一个更大对象的一部分进行处理。
特点：分区都是局部分区索引，一个分区既存放了数据，又存放了索引。
要求：如果表中存在主键或唯一索引，分区列必须是唯一索引的一个组成部分。eg： PRIMARY KEY (`id`, `partition_key`)), PARTITION BY RANGE(partition_key)。


1、char 与 varchar
该字段数据集的平均长度与最大长度是否相差很小，若相差很小优先考虑CHAR类型，反之，考虑VARCHAR类型。
若字段存储的是MD5后的哈希值，或一些定长的值，优先选取CHAR类型。
若字段经常需要更新，则优先考虑CHAR类型，由于CHAR类型为定长，因此不容易产生碎片。
对于字段值存储很小的信息，如性别等，优先选取CHAR类型，因为VARCHAR类型会占用额外的字节保存字符串长度信息。
补充：
     VARCHAR节省了存储空间，所以对性能也有帮助。但是，由于行是变长的，在UPDATE时可能使行变得比原来更长，
	 这就导致需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，在这种情况下，
	 不同的存储引擎的处理方式是不一样的。例如，MyISAM会将行拆成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。
	 其他一些存储引擎也许从不在原数据位置更新数据，导致碎片产生。
	 
2、索引和约束
索引；一种特殊文件，可以提高数据的查询数据，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。
普通索引
唯一索引：索引列的值必须唯一，但允许有空值
主键：一张表最多只能创建一个主键；主键在唯一索引基础上，不允许非空；主键可以被其他表引用为外键。
复合主键：表中的主键含有一个以上的字段，比如：primary key(name, id)；复合主键体现在一个表中的多个字段。
区别：主键和索引都是键，主键是逻辑键，索引是物理键，所以主键实际不存在，而索引存在于数据库中。
eg：对于书，主键相当于页码，索引相当于书的目录
外键：mysql外键使用的存储引擎为innodb, 有些引擎并不支持外键; 外键可以较大程度的保证数据库数据的一致性和完整性。
      设置外键约束的两个表之间具有父子关系，即子表中外键的字段取值范围由父表决定；
	  设置外键一定程度上会降低数据库的速度；字表的外键字段的数据类型和父表要一致。
聚簇索引：有主键选主键、没主键选唯一索引列、没唯一索引列则自动创建一个隐藏的单调递增，一张表只能有一个聚簇索引。
          聚簇索引叶子节点包含数据结构文件及数据文件[数据结构文件.frm(事务id, 回滚指针)、数据文件数据.idb(数据和索引信息)]。
非聚簇索引：除了聚簇索引之外的列。
            非聚簇索引叶子节点指向索引文件[包含指向数据块的指针]，通过索引文件找到数据文件。[索引文件、数据文件是分开的]。
			
3、事务
满足条件：原子性、一致性、隔离性、持久性【过程、执行情况、并发操作、存储状态】
原子性[Atomicity]：【面向执行情况】关注状态，要么全部完成，要么全部不完成
一致性[consistency]：【面向过程状态】事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。
隔离性[isolation]：【面对并发操作,锁机制】一个事务的影响在该事务提交前对其他事务不可见。通过锁实现
持久性[durability]：【面对存储状况】事务完成后，事务对数据库的所有更新将被保存到数据库。即使发生
事务的并发问题：
               脏读：一个事务读到了另一个事务没有提交的数据。事务A修改了一个数据，但未提交，事务B读到了事务A未提交的更新结果，事务B读到的就是脏数据。
			   不可重复读[修改}：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
			   幻读[新增删除]：事务A按照一定条件进行数据读取，期间事务B插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B新插入数据
原理理解：
        原子性、一致性、持久性，通过redo、undo和innodb存储引擎日志缓冲实现
		Inoodb存储引擎通过预写日志保证完整性：
		    事务执行时，Innodb会预先往存储日志缓冲中插入事务日志。事务提交时，会将innodb存储引擎的日志缓冲写入到磁盘重做日志中。
        通过undo进行撤销： 
		    对数据库数据进行修改时，会产生redo及少量的undo, 如果执行rollback, 会使用undo内容进行数据库回滚。回滚过程中, delete回滚insert, insert回滚delete,
            update回滚upadate, undo不一定能撤销回之前的状态，eg: insert造成表空间增大，undo无法恢复撤销等					
分布式事务：
        使用分布式事务时，Innodb存储引擎的事务隔离级别必须设置为序列化，所有节点要么都提交要么都回滚，在任何一个节点出现问题都会导致严重的结果。
事务术语:
        QPS(question per second)、每秒请求的事务	
		TPS(transaction per second)、每秒处理的事务 [TPS=(com_commit + com_rollback)/time, 计算前提：所有事务都是显式提交的，如果是隐式提交，不会参于计算]


4、隔离性的四种级别
Read uncommitted、Read committed、Repeatable read、Serializable
Read uncommitted: 读未提交，一个事务可以读取另一个未提交事务的数据。[脏读、不可重复读、幻读]
Read committed:   读提交，一个事务要等待另一个事务提交后才能读取。[不可重复读，幻读]
Repeatable read： 重复读，就是在开始读取事务（事务开启）时，不再允许修改操作。[幻读]
Serializable：    序列化， 事务串行化顺序执行，可避免脏读、不可重复读及幻读。但是事务级别效率低下，比较耗数据库性能，一般不使用。
隔离级别越低，事务请求的锁越少，或者保持锁的时间越短，mysql默认隔离级别为repeatable read

5、锁
作用：为了支持对共享资源进行并发访问，提供数据的完整性和一致性
表锁：直接锁定整张表，在锁定期间，其他进程无法对该表进行写操作
行锁：仅对指定的记录加锁，这样其他进程还是可以对同一个表中的其他记录进行操作。
页锁：一次锁定相邻的一组记录，介于表锁、行锁之间。
对于MYISAM、BDB、INNODB: 
                        MYISAM存储引擎只支持表锁。随着事务完整性、并发性要求提高，Mysql开始开发基于事务的存储引擎，后来慢慢出现
                        支持页锁的BDB存储引擎和支持行锁的INNODB存储引擎。
                       
                        对MyISAM读操作，不会阻塞其他用户对同一表的读操作，但会阻塞对同一表的写请求；
                        对MyISAM写操作，则会阻塞其他用户对同一表的读和写操作。				

5、三范式
第一范式(1NF)：[原子性]        字段不可再分[即一个字段只存储一项信息]
第二范式(2NF)：[拒绝部分依赖]  为了确定教室，使用"讲师"	+ "班级"作为联合主键，其实仅由班级就可确定[单个主键是不会产生部分依赖的]
第三范式[3NF]：[拒绝传递依赖]  说明教师对应班级的表，不应该出现性别、教室等无关数段。否则会出现各级推论: 主键->教师->班级->教室 
                               重新构建：表1[班级+教师]、表2[教师+班级]、表3[教师+性别+电话联系方式..]
                                 
6、存储过程
定义：一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。
理解：数据库sql语言代码封装与重用[即函数]。
优势：1、存储过程对于很多相似性的删除、更新、新增等操作就变得轻松，并且以后便于管理
      2、存储过程因为sql语句已经编译过了，因此运行的速度比较快
	  3、存储过程可以接受输入参数、输出参数，返回单个货多个结果集及返回值，可以向程序返回错误原因
	  4、存储过程运行比较稳定，只要一次成功，以后都会按这个程序执行
      5、存储过程主要实在服务器上运行，减少对客户机的压力
	  6、存储过程可以包含程序流、逻辑以及对数据库的查询，同时可以实体封装和隐藏数据逻辑
	  7、存储过程可以在单一存储过程中执行一系列sql语句
	  8、存储过程可以从自己的存储过程内引用其他存储过程，可以简化一系列复杂语句

7、视图
了解：虚拟表，从一个表或多个表中导出来的表，作用和真实表一样，包含一系列带有行和列的数据。在视图中，用户可以
      使用select语句查询数据，也可以使用sql增删改查函数操作记录，视图可以使用户操作方便，并保障数据库系统安全。
特点：视图是动态的，因为它与物理模式无关。数据库系统将数据库视图存储为具有连接的sql select语句。当表的数据
      发生变化时，视图也反映了这些数据的变化。
优点：1、允许简化复杂查询[封装代码，后续只需要使用简单的SQL语句可得到想要的结果]
      2、有助于限制对特定用户的数据访问。使用数据库视图将非敏感数据显示给特定用户组。用户只能以只读视图检索数据
	     且无法更新。
缺点：1、从数据库查询数据可能会很慢
      2、每当更改与视图相关联的表的结构时，都必须更改视图