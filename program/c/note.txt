vc6.0++使用
1、编写文本代码[.cpp文件]
2、编译[.obj文件(二进制)]
3、连接[.exe文件]
4、执行[可以选择是否重新编译和连接(如果程序没改动不选择编译)]。
--------程序定义--------
程序 = 算法 +  数据结构
--------注释--------
1、单行注释
   //
2、多行注释
   /**/
--------函数--------
1、C程序总是从main程序开始执行
2、程序调用 
   鉴于程序自上而下编译：
   1、如果函数声明在main之上，可直接在main中调用函数
   2、如果函数声明在main之下，在main中调用需提前声明函数[eg: void shuchu();//声明  shuchu();//使用]
--------变量--------
1、普通变量
   int a, A [C语言区分大小写]
1、符号变量
   1、预编译指令。不占用存储单元
   #define PI 3.14
2、常变量
   1、存在期间，值不能被修改。
   2、占用存储单元
   const int a=3;
--------数据类型--------
基本类型、枚举类型[空类型]、派生类型
1、基本类型
   A、整型类型
      short[2字节]、int[4字节]、short int[2字节]、long int[4字节]、long long int[8字节]、char、bool
   B、浮点类型
      float[4字节]、double[8字节]、复数浮点型
2、枚举类型[enum]-空类型[void]
3、派生类型
   指针类型、数组类型、结构体类型、共用体类型、函数类型
4、结构体类型
   1、定义及赋值
      struct Date{int month; int day; int year; char mark[20];}; struct Student{char name[20]; int age; struct Date birth;}; //定义 
      struct Date birth,birth2 = {...}, {..} ; //全部赋值
      birth.month = ..; //对Date结构类型变量birth下month赋值	
      birth2 = birth; //同类的结构体可以互相赋值
	  scanf("%d, %d, %d, %s", &birth.month, &birth.day, &birth.year, birth.mark); //只能逐个读入结构体变量
   2、数组
      struct Person{char name[20]; int count;}leader[3] = {{"LI", 0}, {"Zhang", 0}, {"Sun", 0}};
   3、指针
      1、结构体变量指针
	     可用(*p).name, 也可用p->name 
         # include <string.h>
         struct Student{long num; char name[20]; char sex; float score;}stu_1, *p; p = &stu_1; stu_1.num = 1; strcpy(stu_1.name, "lilei");
	     printf("%ld, %s", (*p).num, (*p).name); //用指针输出结构体变量stu_1的num及name值
	  2、结构体数组指针
	     struct Student{long num; char name[20]; char sex; float score;}stu_1[3], *p;
		 for(p=stu; p<stu+3; p++){....p->num...p->name..};
--------运算相关--------
1、系统自动转换及强转换
      a = (int)b
   a、强转换
      (int)6.5
   b、系统自动转换
      3+6.5
2、复合运算
   a+=3
   x*=y+8 //相当于x = x*(y+8)
--------常用算法逻辑--------
1、闰年
   "能被4整除，但不能被100整除" 或者 "能被400整除"
2、素数
   除了1和本身外，不能被其他任何整数整除
3、银行存息
   设本金为P0[活期年利率为R, 两次半年定期为W]
   1、一年后本金+利息
      P1=P0(1+R)
   2、二次半年后本金+利息
	  P2=P0(1+W/2)(1+W/2)
4、移盘子问题
   问题描述：古代有一个梵塔，塔内有3个座ABC, 开始时A座上有64个盘，盘子大小
             不等，大的在下，小的在上。要求：将64个盘子从A座移到C座，规定每
			 次只允许移动一个盘，且在移动过程中在3个座上都始终保持大盘在下，
			 小盘在上。在移动过程中可以利用B座 
   问题分析：属于递归问题
             [1、将N-1个盘子从A借助C移到B
			  2、将第N个盘子从A移到C
			  3、将N-1个盘子从B借助A移到C
			  递归结束条件：当n=1时，直接将盘子从A移到C]
			 步骤1、3对象变化，但操作相同[函数A]、步骤2[函数B]
	void AA(n, A, B, C)
	{//将A中A个物体，借助B移到C
		void move(A, C)；
		if(n==1){move(A, C);}
		else{AA(n-1, A, C, B);move(A, C);AA(n-1, B, A, C);}
	}
	void move(A, C){
		printf("move %c to %c\n", A, C);
	}
--------常用错误--------
1、字符串
   1、定义
      单个字符使用单引号、字符串使用双引号
   2、格式化输出
      %c对应单个字符、%s对应字符串
2、循环使用
   for(int i ...)//会出现报错，应使用int i; for(i=1;....)
3、字符指针变量赋值
   1、赋值
      char *a, str[10]; //1
      a = str; //2
      scanf("%s", a);//3
     理解：需先让字符指针变量a指向一个特定地址，然后才能对其赋值
           可以修改字符数组中的每个值，但无法修改字符指针变量的值[即char *b="ss"; b[1]='n'不可行] 
4、结构体变量赋值
   struct Student{long num; char name[20]; char sex; float score;}stu_1;
   无法使用stu_1.name = "lilei" 赋值。可通过<string.h>中strcpy(stu_1.name, "lilei")赋值    
--------代码优化--------
1、先赋值后判断
   while((*to++=*from++)!='\0'); //先赋值，后自增
2、'\0'判断
   while((*to++=*from++)!='\0') 可优化为while((*to++=*from++);
--------函数使用--------  
1、空函数
  作用：提前定义，后续再补上代码
2、递归函数
  int fac(int n){
	if(n<0){printf("..");}
    else if(n==0||n==1){f=1;}
	else = fac(n-1)*n;
	return f;
  }
3、内部函数与外部函数
  1、内部函数
	 作用：限定函数只能在被本文件其他函数调用
     static int fun(int a, int b) 
  2、外部函数
     作用：其他文件可以调用
	 规定：在定义函数时，省略extern，则默认为外部函数
	 extern int fun(int a, int b)
--------变量相关--------
1、程序块
   作用域：变量C作为程序块定义变量，只在程序块中有效 
   int main(){int a,b; {int c; c=a+b}}
2、全局变量
   说明：Max与Nox均为全局变量。Max作用域[1、2、3、4], Nox作用域[3、4]
   建议：1、避免使用全局变量[A:在程序执行过程中一直占用内存 B、增加耦合性]
         2、全局变量定义，使用首字母大写，用于与局部变量做区别
   int Max=1; //1
   void c();//2
   int Nox=2; //3
   int main(){ int a;}//4 
3、C变量存储类别
   自动[auto]、静态[static]、寄存器[register]、外部[extern]
   1、静态变量
      1、静态局部变量
	     int f(int a){static int c=3; c=c+1; printf("%d\n", c)};
		 静态局部变量c在编译时赋初值，且只赋初值一次。
		 后续每调用f, 不在对静态局部变量c赋初值而是保留上次函数调用结束时的值
		 补：虽然静态局部变量在函数调用后仍然存在，但其他函数无法引用。因为静
		     态局部变量仍是局部变量，只能本函数引用。
      2、静态全局变量
	     作用：将全局变量a作用域限制在本文件中，其他文件无法引用
	     static int a=0;
		 int main(){
			return 0;
		 }
   2、寄存器变量
      通常变量存放于内存，控制器发出指令从内存地址中取。
	  但对于高频使用率变量，可以将其作为寄存器变量，存放于cpu中,
	  基于cpu寄存器存取速度远高于内存存取速度，可以提高执行效率
	  register int f;
   3、外部变量
      1、文件内使用外部变量
		 int main(){extern int A, B, C; return 0;}
		 int A, B, C;
	  2、将外部变量拓展到其他文件
	     file A.c
		 #include <stdio.h>
         int A=2;
         int main(){int power(int a); int m = power(A); printf("%d\n", m); return 0;}
	    
		 file B.c
		 extern A;
         int power(int a){return a*a;}
--------数组--------
1、使用
   char string[] = "nihao";
   printf("%s\n", string); //输出结果：nihao 
--------指针--------
术语：一个变量的地址称为该变量的"指针"。
      指针是一个地址(i的指针是2000)，指针变量是存放地址的变量
1、访问方式
   1、直接访问
       a = 3
	  通过变量名访问值
   2、间接访问
      int a=100; int* addr=&a; //不能直接int *p; *p=2, 需先int *p=&a, 然后*p=2
	  先找到存放地址的变量i、再根据i值指示地址访问数据]
2、指针变量使用
   1、指针使用
      int  a=100, b=99; int *p=&a, *q=&b, *m; m = p;p = q;q = m;
	  printf("%d\t%d\n", *p, *q); //p与q交换，可改变值
   2、函数传递	
      int a=100; int *p=&a; swap(p)...swap(int *q){*q=5}; [修改p指向变量值，达到p指向地址修改]	
      规则：不能通过调用函数改变实参指针变量的值[即在函数中执行2.1步骤]，但是可以改变实参指针所指变量的值[即2.2操作]。
   3、访问数组
      int a[10] = {1,2,3,4};
	  1、a[i]
	  2、*(a+i)// 等同于a[i]
	  3、int *p; for(p=a; p<(a+10); p++){...*(p+i)...};
	  对比：C编译是将a[i]转换为*(a+i)处理。建议使用p指针遍历[效率高]
	  4、用函数处理数组
	     int x[2]={1,2}; void change(int x[]){...}; change(x); //change(int x[])中的int x[]相当于int *x, 在函数中对x进行数值修改，原数组值会同步改变
      5、多维数组
	     int a[10][10]; 
         a //二维数组开始地址
         a+1 //即a[1][0]地址
         a[0]+1 //即&a[0][1]
         *(a+1)+1//即a[1][1],鉴于*(a+i)=a[i]
         *(a[i]+j)//即a[i][j]的值
         使用：
			1、使用int (*p)[n] 处理二维数组	
		       int a[3][4] = {1,2,3,4,5,6,7,8,9,0}; int (*p)[4]; p=a; printf("%d\n", *(*(p+2)+3));//输出p[2][3]的值
               理解：int (*p)[4]中，p的类型为int (*)[4], 长度为16, p=a,相当于p指向一个长度为16的4个元素的一维数组。后续使用*(*(p+i)+j)取得数组元素		  
			2、使用int *p处理二维数组
			   int a[3][4] = {1,2,3,4,5,6,7,8,9,0}; int *p,*p_end; p=*a; p_end=p+12-1l; for(; p<p_end;p++){printf("%d\t", *p)}; //输出二维数组所有值
			   理解：p=*a相当于p=a[0][0],p逐加1,即可遍历a二维数组所有地址,然后用*p取得地址对应存储值
	  6、指针数组
	     1、定义
		    一个数组，若其元素均为指针类型数据，称为指针数组. int*  p[4];
		 2、使用 
		    char *name[] = {"Follow me", "Basic"}; printf("%s", name[1]);//输出"Basic"值
			指针数组可以存放字符串，但是不能存放整型值
   4、处理字符串
      char *string = "nihao";
	  printf("%s\n", string); //输出结果: nihao 将nihao字符串的第一个元素地址赋值给string]
   5、访问函数
      1、指针变量调用函数
         int maxix(int x, int y){..}; int(*p)(int x, int y); p=maxix; int a=10,b=9; (*p)(a, b); 
	  2、指针变量作为形参
	     int max(int x, int y){...}; int x=10, y=100; int choose(int x, int y, int(*p)(int, int)); choose(x, y, max);
	  3、返回指针类型的函数
         int* p(int x, int y);	
   6、指向指针的指针
	  char **p //可理解为char* (*p)， p是一个指向char *指针的指针变量[char *p p是一个指针变量，指向char]
	  1、处理字符数组
		 char *ar[] = {"hi", "good", "yeah"}; char **p; int len = strlen(ar), i; for(i=0; i<len; i++){ p = ar+i; printf("%s\n", *p);} //逐个输出ar数组所有字符串
		 理解：p是一个指向字符指针的指针变量. ar数组中每个元素均为指针变量.p=ar+0表示p指向a[0], printf("%d", *p)//打印a[0]地址.  printf("%s", *p)//输出"hi" 
	  2、处理整型数组
		 int a[5] = {1,2,3,4,5}; int *num[5] = {&a[0], &a[1], &a[2], &a[3], &a[4]}; int **p, i; for(i=0; i<5;i++){ p = num+i; printf("%d\n", **p);} //逐个输出a数组所有值		 
   7、void指针类型
      理解：指向"空类型" 或 "不确定指向类型"的指针
      int a = 3;
      void *p = &a;	//空指针p得到a的纯地址，无法通过*p输出a的值
   8、补充
      *p++ 等同于*(p++)
	  ++(*p) 指针p指向变量值自增1，指针变量值不变[即值变，地址不变]
--------动态分配--------
所属头文件: <stdlib.h>
1、malloc函数
   void *malloc(unsigned int size) //在内存的动态存储区中分配一个长度为size的连续空间
   pt =(int *)malloc(100); //开辟100字节的临时分配域。函数值为其第一个字节的地址。[如果失败, 返回null]
2、calloc函数
   void *calloc(unsigned n, unsigned size) //在内存的动态存储区中分配n个长度为size的连续空间[如果失败, 返回null]
   p = (int *)calloc(50, 4); //开辟50*4个字节的临时分配域，把起始地址赋给指针变量p
3、free函数
   void free(void *p) //释放指针变量p所指向的动态空间
   free(p); //释放指针变量p所指向的已分配动态空间
4、realloc函数      
   void *realloc(void *p, unsigned int size) //修改malloc或calloc获得的动态空间大小[重新分配空间,如果失败返回null]
   relloc(p, 50); //将p指向的已分配动态空间修改为50字节 