参考资料：
       [1]https://blog.csdn.net/weixin_42109012/article/details/102726296?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param
--------运行--------
运行环境：Windows10 64位[DOSBOX]
1、环境配置
   参考-参考资料[1]
2、运行程序
   在"ASSEMBLY/ASM"文件夹下编写asm后缀汇编文件
   1、编译[masm hello.asm] 2、连接[link hello.asm] 3、运行[HELLO.EXE] 4、调试[debug hello.exe]
   简洁运行: 
            1、masm "hello.asm路径"\hello; 
			2、link "hello.obj路径"\hello; 
			3、"hello.exe路径"\hello     
2、PSP区
   定义：一共256个字节[10H], DOS用此部分空间和程序进行通信
   程序加载前，PSP在DS:0处。程序加载, 从DS:0往后划分10H用作PSP区[DS:0-DS:10H], 此时CS为DS:10H[程序开始存放位置] 
3、debug调试
   在dosbox下执行debug:默认都是16进制，不需要在数据后添加H标识
   1、寄存器内容
      -r [查看]
	  -r ax[-r ip/cs...改变寄存器ax内容]
   2、内存内容
	  1、查看
		  -d [-d 1000:0 查看从1000段地址开始的内存内容, 直接-d即查看当前cs:ip开始的内存内容（左：地址 中间:16进制值 右:对应ascii值）]
			 [-d 1000:0 9 查看从1000段地址0偏移地址的前10个内存内容	]
			 [-d 1000:0 0 查看从1000段地址0偏移地址的内存内容]
      2、修改
          -e 1000:0 0 1 2 3[修改从1000段地址开始0偏移地址的4个元素，分别赋值0,1,2,3]  
          -e 1000:10 回车 [一个个修改从1000段地址开始0偏移地址的内存内容。内容可为(输入空格表示不对当前内存单元进行改写)]
          -e 1000:0 b8 01 00 b9 02 00 01 c8[往内存写入机器码]
          -a 1000:0 [从1000段地址开始0偏移地址写入汇编指令，直接-a表示从当前cs:ip指向地址开始填汇编指令]
      3、翻译
	      -u 1000:0[将从1000段地址开始0偏移地址的机器码，翻译成汇编指令]
      4、执行
	      -t [执行当前cs:ip指向段地址偏移地址的内存机器码]
   3、加载运行程序
	  debug hello.exe;
	  1、单步运行
	     -t...
      2、选择运行至某处
         -g 000c [如程序从CS: 0000~000F, 可选择000C, 直接-g 000c, 表示执行程序到当前代码段000c处(除000c外，之前代码均执行完)]
         -p [当遇到循环，可在loop ..时，选择-p, debug自动重复执行循环，直到(cx)=0跳出循环位置（-g也行）]
      3、int 21处理
	    -p [Int 21使用-p执行]
   4、退出debug
      -q
   5、补充
	  1、采用段寄存器访问
		  -r ds
		  : 10000
		  -d ds:0 		  
      2、-t操作段寄存器
	     当-t执行修改段寄存器，会自动执行下一条指令
4、伪指令
   汇编指令一共分两种。一种是汇编指令[有对应机器码可以被编译被CPU执行],另一种是伪指令[没有对应机器码，不能被CPU执行，只能被编译器执行]
   assume cs:codesg [将段与寄存器挂钩]
   codesg segment ["codesg段"定义]
          mov ax, 0123H
		  ...
		  mov ax, 4c00H[程序返回指令]
	      int 21H [程序返回指令]
   codesg ends ["codesg段"结束标志]
   end ["源程序的编译"结束标志]
--------CPU--------
1、控制形式
   PC主板上的核心器件通过总线[地址、数据、控制总线]相连。主板的扩展卡槽外接接口卡，CPU通过总线控制外接接口卡，
   从而控制外设
--------8086--------
1、数据总线宽度:16位[一次性可传输16位数据，即2字节]、地址总线宽度:20位[寻址能力达1MB]
2、所有寄存器均为16位
--------总线--------
区分：地址总线、数据总线、控制总线
1、地址总线
   一个CPU有N根地址总线[代表CPU地址总线宽度为N, 可以寻找2的N次方个内存单元]
2、数据总线
   一个CPU有N根数据总线[代表CPU数据总线宽度为N, 可以一次传输N位二进制数据(即N/8个字节)]
3、控制总线
   一个CPU有N根控制总线[代表CPU控制总线宽度为N]
--------存储器--------
1、数据和程序在存储器中以"二进制数据"形式存放 
2、只读存储器[只读，断电后存在], 随机存储器[可读可写，断电后信息丢失]
--------寄存器--------
0、存储
   字单元：存放一个16位的内存单元，由高低连续内存单元组成。
           高地址内存单元中存放数据的高位字节，低地址内存单元存放数据的地位字节
           ["字/字型数据一个字单元/"由2、3两个内存单元组成，则这个字单元起始地址为2，称为2地址字单元]
1、通用寄存器
   作用：存储一般性数据[AX、BX、CX、DX]，其中每个寄存器可分为两个独立的8位寄存器使用(高8，低8)
        [AX分为AH和AL, BX可分为BH和BL, CX可分为CH和CL, DX可分为DH和DL]
2、常见指令
   1、mov ax, 18 [相当于ax = 18]
   2、add ax, 7  [相当于ax = ax + 7]
   3、mov ax, bx [相当于ax = bx]
   4、add ax, bx [相当于ax = ax + bx]
3、20位地址计算
   1、组成
	  CPU使用"地址加法器"将2个16位地址[段地址:偏移地址]合成一个20位的物理地址
      物理地址 = 段地址*16 + 偏移地址[eg: 123C8H =  1230H*16 + 00C8H]
      补： cpu可用不同的段地址和偏移地址表示同一物理地址 
   2、说法
      数据存在内存1230:00c8单元中、数据再1230H段中的00c8H单元中
   3、段寄存器
      种类：CS[指令]、DS、ES、SS	
4、指令相关
   CS: 存放指令段地址、IP：存放指令的偏移地址
   在任意时刻，CPU将CS:IP中的内容当做指令的段地址和偏移地址，用它们合成指令的物理地址到内存中读取指令码
   [执行完后，IP会根据存储指令码的字节长度自增，以使CPU读取下一条指令]
   1、修改CS: IP
      1、完全修改
         jmp 2AE3:3 [执行完后CS为2AE3H, IP为0003H, CPU将从2AE33H处读取指令]
	  2、单独修改IP
	     jmp ax [将ax内容赋给IP]
5、数据相关
   DS:存放数据段地址
   将ds:0内容赋值给寄存器: mov bx, 1000H //  mov ds, bx // mov al, [0]
   mov ax, [0000] [如果ds为0001H, 则0001:0000为00010H, 0000:0010为00010H, 0000:0010与0001:0000指向内存地址相同]
6、栈
   原则:LIFO[fist in last out. 后进先出]数据从栈顶[低字节]进入，栈底为高字节
   SS:存放栈顶段地址 SP:存放栈顶偏移地址[SS:IP永远指向栈顶元素]
   1、指向问题
      当栈空时，SS:SP指向栈空间最高地址单元的下一个单元[8位]
	  8086无法检测栈顶、栈底超界问题
   2、用法
      push 寄存器 [入栈，将一个寄存器中的数据入栈]
	  pop  寄存器 [出栈, 用一个寄存器接受出栈的数据] 
	  注意：出入栈均以字[16位]为一个单位 push [0]、pop [0]
	        执行push or pop，cpu均会改变sp
   3、开栈
      mov ax, 2000
	  mov ss, ax
	  mov sp, 10     [将2000:0000~2000:000F为栈空间，初始化栈顶]
7、符号约定使用
   1、[BX]类型
	  当ds为1000H, bx为0003H
	  mov ax, [bx] [意为: 将1000:0003对应内存地址字单元(16位)的值赋给ax]
	  mov al, [bx] [      将1000:0003对应内存地址单元(8位)的值赋给al]
   2、(bx)-(al)-((ds)*16+(bx))
      通常将(bx)-(al)-((ds)*16+(bx)) [(bx)：bx指向内存地址的内容值(16位), (al): al指向内存地址的内容值(8位),((ds)*16+(bx))... ]
   3、inc
      mov bx, 1
	  inc bx  [执行后,bx=2]
8、循环[loop]
   原理:cpu执行loop指令时，先执行(cx)=(cx)-1, 然后判断cx的值[如果cx不为0则转移至标号处执行程序，如果cx为0则程序向下执行]
     mov ax, 2
     mov cx, 11
   s:add ax, ax
     loop s
9、"字型数据定义-存储"及"段地址的定义-引用"
   1、在程序中定义字型数据
     [dw: 开辟内存空间用于字型数据定义及存放]
	  assume cs:code 
	  code segment 
		   dw 0123h, 0464h [dw写在程序开头，则0123h, 0464h存储位置分别为cs:ip~cs:ip+2、cs:ip+3~cs:ip+4]
            mov bx, 0
			...
            int 21h
      code ends
      end  
	  
   2、由于9.1在程序开头写了dw, 需要声明程序指令开始位置[声明后,ip会指向此偏移地址]
      assume cs:code 
	  code segment 
	       dw 0123h, 0464h
           start: mov bx, 0 [声明start后，程序第一条指令从mov bx, 0此处开始执行]
                  ...
                 int 21h
      code ends
      end 
	 如果不指明入口，CPU会把这些数值数据当成汇编指令执行
   3、段地址定义与引用
      assume cs:code, ds:data, ss:stack [关联]
	  data segment  [数据段]
	       dw 0123h, 0456h, 0789h...
	  data ends
	  stack segment [栈段]
	       dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	  stack ends  
	  code segment  [代码段] 
	       start: mov ax, stack
                  mov ss, ax
                  mov sp, 20h                  
				  ...
		          mov bx, data 
	  其中 mov ax, stack[将stack段地址赋值给ax]
           mov bx, data [将data段地址赋值给bx]	
      补充：如果段中的数据占N个字节，则程序加载后，该段实际占有空间为N%16==0 ? N: (N/16+1)*16		   
--------常见错误--------
1、通用寄存器
  1、计算
     ax低8位al计算，进位不会到达ah中   
  2、赋值
     1、段寄存器
		mov ds, 1000[错误] 8086不能直接将数据存到ds,cs等段寄存器
		mov ds, ax [正确]
        add ds, ax[错误] 
		add ax, ds[错误] 8086段寄存器不能参于加减运算	
	 2、ax等寄存器
        mov ax, [0] [将ds:[0]的0字单元赋给ax(16位)]	
2、理解
  1、数据和程序
     数据和程序没有区别[均属于内存数据, 以2进制存储]，只有当cs:ip指向时才能成为程序，当ds指向时才能成为数据
  2、清零
     mov ax, 0;  
3、debug下和asm程序不同
  1、
     debug下编写：mov ax,123 [表示将0123H赋值给ax]
     notepadd下编写：mov ax, 123[表示将十进制123赋值给ax]
  2、
     debug下编写: mov ax, ffff[正确]
     notepadd下编写: mov ax, 0ffffH[数据不能以字母开头，需添加0]
  3、
     对于mov ax,[0]
     degbug表示：将ds:0数据赋值给ax
     notepadd下表示：将0赋值给ax[或者在notepadd下直接mov ax, ds:[0]] 
4、安全空间
   一般而言，dos方式下，0:200~0:2ff空间中，不会存在系统或其他程序的代码[最好还是-d查看这段区间是否数据全为0]
5、sp设置
   1、使用dw
      1、如果程序只有一个段，那么sp要考虑所有dw
	    eg:
		   code segment
                dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0eddh, 0fedh
                dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
				start: mov ax, cs
					   mov ss, ax
					   mov sp, 30h [两次dw，一共划分了2*(8+16)=48个字节，也就是0030H。
					                实际栈范围为(0010H~002fH, 因为栈空，所以sp初始指向下一个字节单元，即0030H)]
	  2、如果程序数据、栈、代码各自划分一个段，那么sp只需要考虑栈段的大小，并相应设置
	  	  eg:
	     a segment
           dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh
         a ends
         b segment
           dw 0,0,0,0,0,0,0,0
         b ends
         code segment
              start: 
			   mov ax, a [076c]
			   mov ds, ax
			   
			   mov ax, b [076e]
			   mov es, ax
			   
			   mov ax, 1000H
			   mov ss, ax
			   mov sp, 0010H [因为栈段dw初始设置为8个字单元 (8*2)=16个字节,为001H。
			                  实际栈范围为(0000H~000fH, 因为栈空，所以sp初始指向下一个字节单元，即001H)]
********继续学习********
P138 