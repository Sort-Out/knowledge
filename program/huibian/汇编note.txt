参考资料：
       [1]https://blog.csdn.net/weixin_42109012/article/details/102726296?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param
--------运行--------
运行环境：Windows10 64位[DOSBOX]
1、环境配置
   参考-参考资料[1]
2、运行程序
   在"ASSEMBLY/ASM"文件夹下编写asm后缀汇编文件
   1、编译[masm hello.asm] 2、连接[link hello.asm] 3、运行[HELLO.EXE] 4、调试[debug hello.exe]
   简洁运行: 
            1、masm "hello.asm路径"\hello; 
			2、link "hello.obj路径"\hello; 
			3、"hello.exe路径"\hello     
2、PSP区
   定义：一共256个字节[10H], DOS用此部分空间和程序进行通信
   程序加载前，PSP在DS:0处。程序加载, 从DS:0往后划分10H用作PSP区[DS:0-DS:10H], 此时CS为DS:10H[程序开始存放位置] 
3、debug调试
   在dosbox下执行debug:默认都是16进制，不需要在数据后添加H标识
   1、寄存器内容
      -r [查看]
	  -r ax[-r ip/cs...改变寄存器ax内容]
   2、内存内容
	  1、查看
		  -d [-d 1000:0 查看从1000段地址开始的内存内容, 直接-d即查看当前cs:ip开始的内存内容（左：地址 中间:16进制值 右:对应ascii值）]
			 [-d 1000:0 9 查看从1000段地址0偏移地址的前10个内存内容	]
			 [-d 1000:0 0 查看从1000段地址0偏移地址的内存内容]
      2、修改
          -e 1000:0 0 1 2 3[修改从1000段地址开始0偏移地址的4个元素，分别赋值0,1,2,3]  
          -e 1000:10 回车 [一个个修改从1000段地址开始0偏移地址的内存内容。内容可为(输入空格表示不对当前内存单元进行改写)]
          -e 1000:0 b8 01 00 b9 02 00 01 c8[往内存写入机器码]
          -a 1000:0 [从1000段地址开始0偏移地址写入汇编指令，直接-a表示从当前cs:ip指向地址开始填汇编指令]
      3、翻译
	      -u 1000:0[将从1000段地址开始0偏移地址的机器码，翻译成汇编指令]
      4、执行
	      -t [执行当前cs:ip指向段地址偏移地址的内存机器码]
   3、单步加载运行程序
	  debug hello.exe;
	  -t...
	  -p [Int 21使用-p执行]
   4、退出debug
      -q
   5、补充
	  1、采用段寄存器访问
		  -r ds
		  : 10000
		  -d ds:0 		  
      2、-t操作段寄存器
	     当-t执行修改段寄存器，会自动执行下一条指令
4、伪指令
   汇编指令一共分两种。一种是汇编指令[有对应机器码可以被编译被CPU执行],另一种是伪指令[没有对应机器码，不能被CPU执行，只能被编译器执行]
   assume cs:codesg [将段与寄存器挂钩]
   codesg segment ["codesg段"定义]
          mov ax, 0123H
		  ...
		  mov ax, 4c00H[程序返回指令]
	      int 21H [程序返回指令]
   codesg ends ["codesg段"结束标志]
   end ["源程序的编译"结束标志]
--------CPU--------
1、控制形式
   PC主板上的核心器件通过总线[地址、数据、控制总线]相连。主板的扩展卡槽外接接口卡，CPU通过总线控制外接接口卡，
   从而控制外设
--------8086--------
1、数据总线宽度:16位[一次性可传输16位数据，即2字节]、地址总线宽度:20位[寻址能力达1MB]
2、所有寄存器均为16位
--------总线--------
区分：地址总线、数据总线、控制总线
1、地址总线
   一个CPU有N根地址总线[代表CPU地址总线宽度为N, 可以寻找2的N次方个内存单元]
2、数据总线
   一个CPU有N根数据总线[代表CPU数据总线宽度为N, 可以一次传输N位二进制数据(即N/8个字节)]
3、控制总线
   一个CPU有N根控制总线[代表CPU控制总线宽度为N]
--------存储器--------
1、数据和程序在存储器中以"二进制数据"形式存放 
2、只读存储器[只读，断电后存在], 随机存储器[可读可写，断电后信息丢失]
--------寄存器--------
0、存储
   字单元：存放一个16位的内存单元，由高低连续内存单元组成。
           高地址内存单元中存放数据的高位字节，低地址内存单元存放数据的地位字节
           ["字/字型数据一个字单元/"由2、3两个内存单元组成，则这个字单元起始地址为2，称为2地址字单元]
1、通用寄存器
   作用：存储一般性数据[AX、BX、CX、DX]，其中每个寄存器可分为两个独立的8位寄存器使用(高8，低8)
        [AX分为AH和AL, BX可分为BH和BL, CX可分为CH和CL, DX可分为DH和DL]
2、常见指令
   1、mov ax, 18 [相当于ax = 18]
   2、add ax, 7  [相当于ax = ax + 7]
   3、mov ax, bx [相当于ax = bx]
   4、add ax, bx [相当于ax = ax + bx]
3、20位地址计算
   1、组成
	  CPU使用"地址加法器"将2个16位地址[段地址:偏移地址]合成一个20位的物理地址
      物理地址 = 段地址*16 + 偏移地址[eg: 123C8H =  1230H*16 + 00C8H]
      补： cpu可用不同的段地址和偏移地址表示同一物理地址 
   2、说法
      数据存在内存1230:00c8单元中、数据再1230H段中的00c8H单元中
   3、段寄存器
      种类：CS[指令]、DS、ES、SS	
4、指令相关
   CS: 存放指令段地址、IP：存放指令的偏移地址
   在任意时刻，CPU将CS:IP中的内容当做指令的段地址和偏移地址，用它们合成指令的物理地址到内存中读取指令码
   [执行完后，IP会根据存储指令码的字节长度自增，以使CPU读取下一条指令]
   1、修改CS: IP
      1、完全修改
         jmp 2AE3:3 [执行完后CS为2AE3H, IP为0003H, CPU将从2AE33H处读取指令]
	  2、单独修改IP
	     jmp ax [将ax内容赋给IP]
5、数据相关
   DS:存放数据段地址
   将ds:0内容赋值给寄存器: mov bx, 1000H //  mov ds, bx // mov al, [0]
   mov ax, [0000] [如果ds为0001H, 则0001:0000为00010H, 0000:0010为00010H, 0000:0010与0001:0000指向内存地址相同]
6、栈
   原则:LIFO[fist in last out. 后进先出]数据从栈顶[低字节]进入，栈底为高字节
   SS:存放栈顶段地址 SP:存放栈顶偏移地址[SS:IP永远指向栈顶元素]
   1、指向问题
      当栈空时，SS:SP指向栈空间最高地址单元的下一个单元[8位]
	  8086无法检测栈顶、栈底超界问题
   2、用法
      push 寄存器 [入栈，将一个寄存器中的数据入栈]
	  pop  寄存器 [出栈, 用一个寄存器接受出栈的数据] 
	  注意：出入栈均以字[16位]为一个单位 push [0]、pop [0]
	        执行push or pop，cpu均会改变sp
   3、开栈
      mov ax, 2000
	  mov ss, ax
	  mov sp, 10     [将2000:0000~2000:000F为栈空间，初始化栈顶]
7、符号约定使用
   1、[BX]类型
	  当ds为1000H, bx为0003H
	  mov ax, [bx] [意为: 将1000:0003对应内存地址字单元(16位)的值赋给ax]
	  mov al, [bx] [      将1000:0003对应内存地址单元(8位)的值赋给al]
   2、(bx)-(al)-((ds)*16+(bx))
      通常将(bx)-(al)-((ds)*16+(bx)) [(bx)：bx指向内存地址的内容值(16位), (al): al指向内存地址的内容值(8位),((ds)*16+(bx))... ]
   3、inc
      mov bx, 1
	  inc bx  [执行后,bx=2]
--------常见错误--------
1、通用寄存器
  1、计算
     ax低8位al计算，进位不会到达ah中   
  2、赋值
     1、段寄存器
		mov ds, 1000[错误] 8086不能直接将数据存到ds,cs等段寄存器
		mov ds, ax [正确]
        add ds, ax[错误] 
		add ax, ds[错误] 8086段寄存器不能参于加减运算	
	 2、ax等寄存器
        mov ax, [0] [将ds:[0]的0字单元赋给ax(16位)]	
2、理解
  1、数据和程序
     数据和程序没有区别[均属于内存数据, 以2进制存储]，只有当cs:ip指向时才能成为程序，当ds指向时才能成为数据
  2、清零
     mov ax, 0;  
********继续学习********
P99 LOOP指令